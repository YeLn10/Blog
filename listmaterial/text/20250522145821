构造！题解是对编码分块，这是诡谲的，但是确实很妙。

为什么会这样想呢，毕竟限制是$\sqrt n$，对编码分了块后，看有没有什么方法能限制只有一个块连的同色点。（连边方法是二进制下不同的位置只有1，也就是本身每个编码对应一个点，这个点的只有那个位置的数与原点不同。这里就是说只有那个块对应的点连的才是同色点）

然后就对这个编码分块，比如$000|010|110$，然后我们要找一种方法，让只有一个块连的同色点。

找到的方法是，有一块全0就反色这个点。这个点连的n个点中，只有没有全0的会和他同色，否则那个点也反色了。在同色点(没有全0的点)中，不同的位置一定在全0的块内（那肯定啊，毕竟他没有全0，那个块肯定不一样），然后由于块长是$\sqrt n$，一共就$\sqrt n$的同色点和他相连！对于没有反色的，可以同样分析。

很妙的做法啊！！！

```cpp
/*
「頼むよ神様、こんな人生だったんだ。
拜托了，神啊，都已经是这样的人生了……
せめて一度ぐらい、幸せな梦を见させて」
至少让我做一次幸福的梦吧……
*/
#include<bits/stdc++.h>
using namespace std;
#define mid ((l+r)>>1)
#define N 114514*2
#define M 100000000
#define inf 114514191
#define ll long long

/*
对编码分块是诡谲的
为什么会这样想呢，毕竟要看怎么去连边，反色的点会造成什么影响
可以发现如果对编码分块后，比如000\010\110后，有一块全0就反色这个点
然后再看这个点连的n个点中，只有没有全0的会和他连，否则那个点也反色了。
那还需要，只有一个位置的数不同，那必须是原点那个全0的块不同，毕竟这个点没有全0的
然后那个块就只有sqrt(n)个，毕竟就按sqrt(n)分的块
很妙的做法啊！！！
*/
signed main()
{
    int n;cin>>n;
    int m=sqrt(n-1)+1;
    for(int i=0,LIM=(1<<n)-1;i<=LIM;i++)
    {
        int t=__builtin_popcount(i)&1;
        int flag=0;
        for(int x=i,c=0;c<n;c+=m,x>>=m)
        {
            int res=x&((1<<m)-1);
            if(res==0) flag=1;
        }
        if(flag) t^=1;
        cout<<t;
    }    
    return 0;
}
```